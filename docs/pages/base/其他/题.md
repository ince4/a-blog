# 【题】
## webpack
loader、plugin、entry、output、mode、
entryOption、run、compile、compilation、make、emit、done

entryOption：开始解析配置文件时触发。
run：构建开始时触发。
compile：开始编译时触发。
compilation：编译过程中触发。
make：执行构建任务时触发。
afterCompile：编译完成时触发。
emit：生成资源并输出到目标文件夹前触发。
afterEmit：输出完成后触发。
done：打包完成时触发。

## webpack优化
include、exclude减少 loader搜索范围
babel-loader开启缓存
thread-loader、Happypack将 loader 由单进程转为多进程
DllPlugin第三方库单独打包，避免每次构建不常用的库
开启treeshaking

## webpack4 5区别
性能提升 更快构建更小体积、持久化缓存（存在磁盘而非内存中，不仅在一次构建中有效）、模块联邦

## Cookie传输安全
使用https、设置HttpOnly、SameSite属性，设置过期时间（max-age）、内容进行加密

## vue优化
v-for 使用唯一的 key
使用 computed
keep-alive 缓存
路由、组件懒加载
虚拟列表/懒加载

## vue通信
props、emit
总线 event.$emit、vuex、$parent、$refs、$attr（props和emit候补）、provide、inject(动态数据 computed)

## vue 生命周期 
父组件先实例化
子组件先渲染完

## mixins顺序
冲突时以组件数据优先
钩子函数在组件之前按顺序调用

## cdn回源
内容分发网络
回源 就是说 CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。

## ssg
SSG 在构建时生成完整的静态 HTML 文件，这些文件包含了整个网站的内容。这些文件之后可以直接被服务器提供给用户，不需要在每次请求时动态生成。 适用于内容不频繁变化的网站，容易进行缓存和分发

## 工程化
概念：前端工程化是一个体系，以项目迭代过程中的前端开发为主要服务对象，涉及开发、构建、测试、部署等环境，通过一系列和工具和规范，目标是提高效率、规范和性能。 脚手架、cicd、自动化测试工具等

## currentTarget、target
target 始终表示事件的起源，而 currentTarget 表示当前正在处理事件的元素

## flex
flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto
auto (1 1 auto)
1 (1 1 0)
none (0 0 auto)。
0 (0 0 0)

## mvvm
数据驱动视图，视图响应改变数据

## router
监听hashchange、history.popstate pushState
hash模式改变不用发请求到服务器，history模式需要后端配合，否则会404

## seo
可以使用预渲染的方式生成静态html，提高性能减少负担，对爬虫更友好

## react、vue区别
vue基于响应式，reactt需要手动setState更新
react基于状态，单项数据流

函数式编程 不可变性、无副作用
react函数式编程较为灵活，适合复杂大型应用

## 为什么异步渲染
如果同步进行会占用大量的主线程资源，导致页面卡顿、响应变慢；所以采用异步渲染的方式，将变化收集到异步队列中统一更新，可以避免阻塞主线程，提高页面性能和流畅度。

## keep-alive
用来缓存组件实例，保存状态
使用LRU算法保存vnode

## src和href
src会替换当前元素，href用于在文档和引用资源之间建立联系。
src会阻塞后续一些资源的加载

## 收获
面对这种线上问题不仅要建立监控，能即时把控项目情况，还需要建立可靠的流程和系统第一时间控制并消除影响

## wacher
computed watcher：computed 对应计算属性的watcher
render watcher：组件中数据的变化
user watcher：监听属性变化 执行响应回调（一些异步任务etc）

## 垂直居中
flex布局 设置justify-content 和 align-items
grid布局   place-items: center
margin: 0 auto
绝对定位 + 负边距
calc 计算
text-align: center 居

## jsbridge
注入api 例如window对象（一般都是同步的）
劫持 url scheme。兼容性更好
如 iframe.src 发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL Scheme 和 携带的参数 进行对应操作。

postMessage进行通讯，前端监听message
## requestAnimationFrame
定时器运行时间不稳定，不能稳定触发准时渲染

## 硬件加速
transform（ translate3d、translateZ(0)等）
opacity
filter（滤镜：drop-shadow()、opacity()，函数与已有的box-shadow、opacity属性很相似；不同之处在于，通过滤镜，一些浏览器为了更好的性能会提供硬件加速）
will-change：哪一个属性即将发生变化，进而进行优化。

## http版本 
## 响应式

## session
在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文， 这点和 session cookies 的运行方式不同。
window.open("同源页面") 或者a标签新开的页面会

## keep-alive
1. 根据 include 和 exclude 判断当前组件是否需要被缓存
2. 命中缓存则直接获取，同时更新 key 的位置。
    根据组件 id 和 tag 生成缓存 key，去缓存对象(**this.cache**)中查找是否存在，存在则取出缓存值并更新该 key在 keys 中的位置**（更新key的位置是实现LRU置换策略的关键）**
3. 未命中缓存则设置进入缓存，同时检查缓存的实例是否超过 max 值，如果超过 max，则删除 this.cache 中第一个实例
4. 将已缓存的实例 keepAlive 设置为 true，这样下次渲染组件不会执行 created 和 mounted 钩子

## 强缓存失效
手动刷新强缓存失效
ctrl+f5强缓存协商缓存失效

## inp和fid
FID 只上报用户第一次与页面交互的响应性
inp是从交互到下一次绘制的延时

## 异常捕获