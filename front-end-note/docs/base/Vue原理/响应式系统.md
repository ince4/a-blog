# 响应式系统
Vue 在初始化数据时，会使用 Object.defineProperty 重新定义 data 中的所有属性（Vue3.0 后则使用 Proxy 实现响应式系统），当页面使用对应属性时，首先会进行依赖收集(收集当前组件的 watcher 对象)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。

## 1、MVVM模式与数据响应式原理
Vue 设计受到 MVVM 模型的启发，体现在 Vue 中的数据响应式系统中。  
从 MVVM 模式出发分析 Vue 响应系统，Model 层代表数据模型，View 代表 UI 组件，ViewModel 是 View 和 Model 层的桥梁。  

数据会绑定到 viewModel层并自动将数据渲染到页面中，视图变化的时候会通知 viewModel 层更新数据，而 Model 层的变化也会通过 ViewModel 自动反映在 View 上，也就是采用了双向绑定。  

另一方面 MVC 模式中各层之间的通信都是单向的，View 传送指令到 Controller、Controller 完成业务逻辑后，要求 Model 改变状态、Model 将新的数据发送到 View，用户得到反馈。

## 2、observer基本实现
当一个 Vue 实例被创建时，它会在初始化阶段将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。当这些 property 的值发生改变时，视图将会产生响应。

通过 Object.defineProperty（Vue3.0 为 Proxy）实现 data 属性的响应式化（数据双向绑定）。

```javascript
// 监听对象属性，对其属性进行响应式化
function observer(target) {
    if(typeof target !== 'object' || target === null) {
		return target
	}

	Object.keys(target).forEach((key)=> {
        defineReactive(target, key, target[key])
    })
}

function defineReactive(target, key, val) {
    observe(val) // 对于值为对象类型的属性进行深度监听
    Object.defineProperty(target, key, {
        get() {
			return val
        },
        set(newVal) {
            if (val !== newVal)
			val = newVal // val 变量处于闭包中，确保 get 取得变量的值是最新的
			updateView() // 视图更新
        }
    });
}
```

## 3、动态监听数组
Vue 通过监听数组方法实现数组的动态响应。  
需要对 observer 进行拓展

```javascript
// 维护一个方法列表， 当使用列表内包含的方法时，会在方法执行完成后显示的调用视图更新的操作
const ArrayPrototype= Array.prototype
const reactiveMethods= Object.create(ArrayPrototype)
['push', 'pop', 'shift', 'unshift', 'splice'].forEach(method => {
	reactiveMethods[method] = function (...args) {
		const result = ArrayPrototype[method].apply(this, args)
		updateView()

		return result
	}
})

function observer(target) {
    if(typeof target === 'object' || target === null) {
		return target
	}

	// -- 新增部分 --
	if (Array.isArray(target)) {
		// 调用重写后的数组方法实现响应式
		Object.setPrototypeOf(target, reactiveMethods)
	}


	Object.keys(target).forEach((key)=> {
        defineReactive(target, key, target[key])
    })
}

function defineReactive(target, key, val) {
	// ...
}
```
## 4、依赖收集
## 5、总结
### 缺陷
Vue2.x 版本中的响应式系统原理是通过 Object.defineProperty() 方法实现的，存在深度遍历递归计算开销大、无法观察到对象新增/删除属性和数组 length 的变化等问题（因此需要 Vue.set 与 Vue.delete方法）。以上问题都在 Vue3.0 当中有所改善，具体变化内容请在后续章节[事件循环](/base/浏览器/事件循环)中查看。

### 总体流程
首先在 observer 的过程中会注册 get 方法，该方法用来进行「依赖收集」。在它的闭包中会有一个 Dep 对象，这个对象用来存放 Watcher 对象的实例。其实「依赖收集」的过程就是把 Watcher 实例存放到对应的 Dep 对象中去。get 方法可以让当前的 Watcher 对象（Dep.target）存放到它的 subs 中（addSub）方法，在数据变化时，set 会调用 Dep 对象的 notify 方法通知它内部所有的 Watcher 对象进行视图更新。

这是 Object.defineProperty 的 set/get 方法处理的事情，那么「依赖收集」的前提条件还有两个：

触发 get 方法；
新建一个 Watcher 对象。
这个我们在 Vue 的构造类中处理。新建一个 Watcher 对象只需要 new 出来，这时候 Dep.target 已经指向了这个 new 出来的 Watcher 对象来。而触发 get 方法也很简单，实际上只要把 render function 进行渲染，那么其中的依赖的对象都会被「读取」，这里我们通过打印来模拟这个过程，读取 test 来触发 get 进行「依赖收集」。