# 异步编程
JavaScript作为浏览器脚本语言，主要用途是与用户互动以及操作 DOM，决定了它单线程的特点。为解决代码长时间阻塞，Javascript 语言将任务的执行模式分成同步和异步两种。

> JS中常见异步任务有定时器、DOM事件绑定、网络请求等

## 1、回调函数
JS 中函数可以作为参数传递。异步任务中可以通过在合适的时候调用回调函数，也就是执行参数化的函数完成目标任务。

``` javascript
ajax(url, () => {
	// 处理数据
})
```

使用回调函数作为异步任务解决方法的主要问题在于处理存在依赖关系的任务时，容易产生被称为“回调地狱”的多层函数嵌套问题。会导致代码高度耦合，不利于维护和拓展。

``` javascript
ajax(url, () => {
    // 处理逻辑
    ajax(url1, () => {
        // 处理逻辑
        ajax(url2, () => {
            // 处理逻辑
        })
    })
})
```

## 2、Promise
Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject，作用分别是将 Promise 状态从 Pending 变为 fulfilled / rejected。  
Promise 实例生成后，可用 then 方法指定 fulfilled 状态和 rejected 状态的回调函数。

``` javascript
function timeout(ms) {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, ms, 'done')
    })
}

timeout(100).then((value) => {
  console.log(value) // done
})
```

Promise.then 方法的返回值是一个新的 Promise 对象，实现了链式调用从而避免了回调地狱的出现。
``` javascript
ajax(url)
    .then(res => {
        console.log(res)
        return ajax(url1)
    }).then(res => {
        console.log(res)
        return ajax(url2)
    }).then(res => console.log(res))
```


> **promise/A+规范内容**
>- 一个 promise 实例的当前状态只能是 pending、fulfilled 和 rejected 三种之一。状态改变只能是 pending 到fulfilled或者 pending 到 rejected。状态改变不可逆。  
>- promise 的 then 方法接收两个可选参数，表示 promise 状态改变时的回调 promise.then(onFulfilled, onRejected)。then 方法返回一个 promise，then 方法可被同一个 promise 调用多次。

<!-- #### 简易实现
``` javascript
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'

class AjPromise {
    constructor(fn) {
        //当前状态
        this.state = PENDING
        //终值
        this.value = null
        //拒因
        this.reason = null
        //成功态回调队列
        this.onFulfilledCallbacks = []
        //拒绝态回调队列
        this.onRejectedCallbacks = []

        //成功态回调
        const resolve = value => {
            // 使用macro-task机制(setTimeout),确保onFulfilled异步执行,且在 then 方法被调用的那一轮事件循环之后的新执行栈中执  行。
            setTimeout(() => {
                if (this.state === PENDING) {
                    // pending(等待态)迁移至 fulfilled(执行态),保证调用次数不超过一次。
                    this.state = FULFILLED
                    // 终值
                    this.value = value
                    this.onFulfilledCallbacks.map(cb => {
                        this.value = cb(this.value)
                    })
                }
            })
        }
        //拒绝态回调
        const reject = reason => {
            // 使用macro-task机制(setTimeout),确保onRejected异步执行,且在 then 方法被调用的那一轮事件循环之后的新执行栈中执   行。 (满足要求 -> 调用时机)
            setTimeout(() => {
                if (this.state === PENDING) {
                    // pending(等待态)迁移至 fulfilled(拒绝态),保证调用次数不超过一次。
                    this.state = REJECTED
                    //拒因
                    this.reason = reason
                    this.onRejectedCallbacks.map(cb => {
                        this.reason = cb(this.reason)
                    })
                }
            })
        }
        try {
            //执行promise
            fn(resolve, reject)
        } catch (e) {
            reject(e)
        }
    }
    then(onFulfilled, onRejected) {
        typeof onFulfilled === 'function' && this.onFulfilledCallbacks.push(onFulfilled)
        typeof onRejected === 'function' && this.onRejectedCallbacks.push(onRejected)
        // 返回this支持then 方法可以被同一个 promise 调用多次
        return this
    }
}
``` -->

## 3、Generator
执行 Generator 函数会返回一个遍历器（Iterator）对象
> Iterator为各种不同的数据结构提供统一的访问机制，Iterator 接口主要供for...of消费

``` javascript
function* foo(x) {
    var y = 2 * (yield (x + 1))
    var z = yield (y / 3)
    return (x + y + z)
}

var a = foo(5)
a.next() // Object{value:6, done:false}
a.next() // Object{value:NaN, done:false}
a.next() // Object{value:NaN, done:true}

var b = foo(5)
b.next() // { value:6, done:false }
b.next(12) // { value:8, done:false }
b.next(13) // { value:42, done:true }
```
next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。
从语义上讲，第一个next方法用来启动遍历器对象，所以不应带有参数。

## 4、async、await
async 是 Generator 的语法糖，用来定义一个返回 Promise 对象的异步函数，可以使用then方法添加回调函数。

```javascript
async function foo() {
    return 'resolved';
}
foo().then(value => {
    console.log(value) // resolved
})
```
 await 操作符用于等待一个Promise 对象。它只能在异步函数 async function 中使用。函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。

```javascript
async function test() {
    console.log(100) // step2: 输出100
    let x = await 200 // step3: 遇到 await 返回，等待异步操作执行完成
    console.log(x) // step5：输出 x = 200
}

test() // step1: 创建 test 函数的执行上下文进入执行栈
console.log(300) // step4： 同步代码执行，输出300

// 输出结果为 100 300 200
```
step3 部分 await 操作符调用了 Promise.resolve 方法，且后续代码进入微任务队列，等到宏任务结束后执行。（详细内容于下一节事件循环章节说明）  
以上代码等同于
```javascript
function test() {
    console.log(100) // step2: 输出100

    new Promise((resolve,reject) => {
        resolve(200); // step3: 回调函数进入微任务队列，等待事件循环
    }).then(value => {
        console.log(value) //step5：输出 x = 200
    })
}

test() // step1: 创建 test 函数的执行上下文进入执行栈
console.log(300) // step4： 同步代码执行，输出300

// 输出结果为 100 300 200
```